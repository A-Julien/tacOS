<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tac0S: Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tac0S
   </div>
   <div id="projectbrief">Template Affectional Command Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Thread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The following class defines a "thread control block" &ndash; which represents a single thread of execution.  
 <a href="class_thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread_8h_source.html">thread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeef00ecb5eda30734cff97a0ac492bdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#aeef00ecb5eda30734cff97a0ac492bdd">Thread</a> (const char *debugName)</td></tr>
<tr class="memdesc:aeef00ecb5eda30734cff97a0ac492bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#aeef00ecb5eda30734cff97a0ac492bdd" title="Thread::Thread Initialize a thread control block, so that we can then call Thread::Fork. ">Thread::Thread</a> Initialize a thread control block, so that we can then call <a class="el" href="class_thread.html#a7631955bc5e11232bb682baa467baf5f" title="Thread::Fork Invoke (*func)(arg), allowing caller and callee to execute concurrently. ">Thread::Fork</a>.  <a href="#aeef00ecb5eda30734cff97a0ac492bdd">More...</a><br /></td></tr>
<tr class="separator:aeef00ecb5eda30734cff97a0ac492bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d9edd3a1a776cbc27dedff949c9726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a37d9edd3a1a776cbc27dedff949c9726">~Thread</a> ()</td></tr>
<tr class="memdesc:a37d9edd3a1a776cbc27dedff949c9726"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a37d9edd3a1a776cbc27dedff949c9726" title="Thread::~Thread De-allocate a thread. ">Thread::~Thread</a> De-allocate a thread.  <a href="#a37d9edd3a1a776cbc27dedff949c9726">More...</a><br /></td></tr>
<tr class="separator:a37d9edd3a1a776cbc27dedff949c9726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7631955bc5e11232bb682baa467baf5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a7631955bc5e11232bb682baa467baf5f">Fork</a> (VoidFunctionPtr func, int arg)</td></tr>
<tr class="memdesc:a7631955bc5e11232bb682baa467baf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a7631955bc5e11232bb682baa467baf5f" title="Thread::Fork Invoke (*func)(arg), allowing caller and callee to execute concurrently. ">Thread::Fork</a> Invoke (*func)(arg), allowing caller and callee to execute concurrently.  <a href="#a7631955bc5e11232bb682baa467baf5f">More...</a><br /></td></tr>
<tr class="separator:a7631955bc5e11232bb682baa467baf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#adbc2bfb172d2eff4b46882aade9eeb8a">Yield</a> ()</td></tr>
<tr class="memdesc:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#adbc2bfb172d2eff4b46882aade9eeb8a" title="Thread::Yield Relinquish the CPU if any other thread is ready to run. If so, put the thread on the en...">Thread::Yield</a> Relinquish the CPU if any other thread is ready to run. If so, put the thread on the end of the ready list, so that it will eventually be re-scheduled.  <a href="#adbc2bfb172d2eff4b46882aade9eeb8a">More...</a><br /></td></tr>
<tr class="separator:adbc2bfb172d2eff4b46882aade9eeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a4c1e62087511b69068220840244a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a187a4c1e62087511b69068220840244a">Sleep</a> ()</td></tr>
<tr class="memdesc:a187a4c1e62087511b69068220840244a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a187a4c1e62087511b69068220840244a" title="Thread::Sleep Relinquish the CPU, because the current thread is blocked waiting on a synchronization ...">Thread::Sleep</a> Relinquish the CPU, because the current thread is blocked waiting on a synchronization variable (<a class="el" href="class_semaphore.html" title="The following class defines a &quot;semaphore&quot; whose value is a non-negative integer. The semaphore has on...">Semaphore</a>, <a class="el" href="class_lock.html">Lock</a>, or <a class="el" href="class_condition.html">Condition</a>). Eventually, some thread will wake this thread up, and put it back on the ready queue, so that it can be re-scheduled.  <a href="#a187a4c1e62087511b69068220840244a">More...</a><br /></td></tr>
<tr class="separator:a187a4c1e62087511b69068220840244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43c788c40e9783311c970bcea7239b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a1e43c788c40e9783311c970bcea7239b">Finish</a> ()</td></tr>
<tr class="memdesc:a1e43c788c40e9783311c970bcea7239b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a1e43c788c40e9783311c970bcea7239b" title="Thread::Finish Called by ThreadRoot when a thread is done executing the forked procedure. ">Thread::Finish</a> Called by ThreadRoot when a thread is done executing the forked procedure.  <a href="#a1e43c788c40e9783311c970bcea7239b">More...</a><br /></td></tr>
<tr class="separator:a1e43c788c40e9783311c970bcea7239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6657ff14b9c6866eadd85ea32c9147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#afa6657ff14b9c6866eadd85ea32c9147">CheckOverflow</a> ()</td></tr>
<tr class="memdesc:afa6657ff14b9c6866eadd85ea32c9147"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#afa6657ff14b9c6866eadd85ea32c9147" title="Thread::CheckOverflow Check a thread&#39;s stack to see if it has overrun the space that has been allocat...">Thread::CheckOverflow</a> Check a thread's stack to see if it has overrun the space that has been allocated for it. If we had a smarter compiler, we wouldn't need to worry about this, but we don't.  <a href="#afa6657ff14b9c6866eadd85ea32c9147">More...</a><br /></td></tr>
<tr class="separator:afa6657ff14b9c6866eadd85ea32c9147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39061ce2692542188f82f909d005b1c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a39061ce2692542188f82f909d005b1c3">setStatus</a> (<a class="el" href="thread_8h.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a> st)</td></tr>
<tr class="memdesc:a39061ce2692542188f82f909d005b1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a39061ce2692542188f82f909d005b1c3" title="Thread::setStatus Set the status as in parameter with debug info. ">Thread::setStatus</a> Set the status as in parameter with debug info.  <a href="#a39061ce2692542188f82f909d005b1c3">More...</a><br /></td></tr>
<tr class="separator:a39061ce2692542188f82f909d005b1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed303e0688ec792e41fb9b7429a3d948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed303e0688ec792e41fb9b7429a3d948"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> ()</td></tr>
<tr class="separator:aed303e0688ec792e41fb9b7429a3d948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad707af00a9ce1a1d324804e7c73dc4ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad707af00a9ce1a1d324804e7c73dc4ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> ()</td></tr>
<tr class="separator:ad707af00a9ce1a1d324804e7c73dc4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607396f3a39a51a46b62177cf177924a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a607396f3a39a51a46b62177cf177924a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUserThread</b> (void *userThreadAdress)</td></tr>
<tr class="separator:a607396f3a39a51a46b62177cf177924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e83abdaea0e9e3baf9be363a4aa9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a608e83abdaea0e9e3baf9be363a4aa9e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>getUserThreadAdress</b> ()</td></tr>
<tr class="separator:a608e83abdaea0e9e3baf9be363a4aa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b2fad5e589fa07ccdbbaae168eddba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b2fad5e589fa07ccdbbaae168eddba"></a>
<a class="el" href="thread_8h.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getStatus</b> ()</td></tr>
<tr class="separator:a50b2fad5e589fa07ccdbbaae168eddba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d35dfaad9bc0df930af2ddc44e62c90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d35dfaad9bc0df930af2ddc44e62c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#a0d35dfaad9bc0df930af2ddc44e62c90">enterCritique</a> ()</td></tr>
<tr class="memdesc:a0d35dfaad9bc0df930af2ddc44e62c90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#a0d35dfaad9bc0df930af2ddc44e62c90" title="Thread::enterCritique Get a semaphore for &quot;critic area&quot; code with still having interrupt. ">Thread::enterCritique</a> Get a semaphore for "critic area" code with still having interrupt. <br /></td></tr>
<tr class="separator:a0d35dfaad9bc0df930af2ddc44e62c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3e7603363d4e79fb21d117be3b60a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3e7603363d4e79fb21d117be3b60a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#ace3e7603363d4e79fb21d117be3b60a8">enterCritiqueExt</a> ()</td></tr>
<tr class="memdesc:ace3e7603363d4e79fb21d117be3b60a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#ace3e7603363d4e79fb21d117be3b60a8" title="Thread::enterCritiqueExt From exterior of a thread Get a semaphore for &quot;critic area&quot; code with still ...">Thread::enterCritiqueExt</a> From exterior of a thread Get a semaphore for "critic area" code with still having interrupt Basicly stopped the thread when the thread is'nt in critique mode No exit statut for this just exit and call ReadyToRun form the scheduler. <br /></td></tr>
<tr class="separator:ace3e7603363d4e79fb21d117be3b60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02997d5ff324b4da69e637bd03e3395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa02997d5ff324b4da69e637bd03e3395"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread.html#aa02997d5ff324b4da69e637bd03e3395">exitCritique</a> ()</td></tr>
<tr class="memdesc:aa02997d5ff324b4da69e637bd03e3395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_thread.html#aa02997d5ff324b4da69e637bd03e3395" title="Thread::exitCritique Drop the semaphore for the critique zone of code, see Thread::enterCritique. ">Thread::exitCritique</a> Drop the semaphore for the critique zone of code, see <a class="el" href="class_thread.html#a0d35dfaad9bc0df930af2ddc44e62c90" title="Thread::enterCritique Get a semaphore for &quot;critic area&quot; code with still having interrupt. ">Thread::enterCritique</a>. <br /></td></tr>
<tr class="separator:aa02997d5ff324b4da69e637bd03e3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4d5cdf2e46ff4d24da0dd06615bf1d48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d5cdf2e46ff4d24da0dd06615bf1d48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stopped</b> = false</td></tr>
<tr class="separator:a4d5cdf2e46ff4d24da0dd06615bf1d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2bb081117d991874600bc67bed3a68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee2bb081117d991874600bc67bed3a68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inAMutex</b> =false</td></tr>
<tr class="separator:aee2bb081117d991874600bc67bed3a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The following class defines a "thread control block" &ndash; which represents a single thread of execution. </p>
<p>Every thread has: an execution stack for activation records ("stackTop" and "stack") space to save CPU registers while not running ("machineState") a "status" (running/ready/blocked)</p>
<p>Some threads also belong to a user address space; threads that only run in the kernel have a NULL address space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeef00ecb5eda30734cff97a0ac492bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#aeef00ecb5eda30734cff97a0ac492bdd" title="Thread::Thread Initialize a thread control block, so that we can then call Thread::Fork. ">Thread::Thread</a> Initialize a thread control block, so that we can then call <a class="el" href="class_thread.html#a7631955bc5e11232bb682baa467baf5f" title="Thread::Fork Invoke (*func)(arg), allowing caller and callee to execute concurrently. ">Thread::Fork</a>. </p>
<p>"threadName" is an arbitrary string, useful for debugging. </p>

</div>
</div>
<a class="anchor" id="a37d9edd3a1a776cbc27dedff949c9726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#a37d9edd3a1a776cbc27dedff949c9726" title="Thread::~Thread De-allocate a thread. ">Thread::~Thread</a> De-allocate a thread. </p>
<p>NOTE: the current thread <em>cannot</em> delete itself directly, since it is still running on the stack that we need to delete.</p>
<p>NOTE: if this is the main thread, we can't delete the stack because we didn't allocate it &ndash; we got it automatically as part of starting up Nachos. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afa6657ff14b9c6866eadd85ea32c9147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::CheckOverflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#afa6657ff14b9c6866eadd85ea32c9147" title="Thread::CheckOverflow Check a thread&#39;s stack to see if it has overrun the space that has been allocat...">Thread::CheckOverflow</a> Check a thread's stack to see if it has overrun the space that has been allocated for it. If we had a smarter compiler, we wouldn't need to worry about this, but we don't. </p>
<p>NOTE: Nachos will not catch all stack overflow conditions. In other words, your program may still crash because of an overflow.</p>
<p>If you get bizarre results_test (such as seg faults where there is no code) then you <em>may</em> need to increase the stack size. You can avoid stack overflows by not putting large data structures on the stack. Don't do this: void foo() { int bigArray[10000]; ... } </p>

</div>
</div>
<a class="anchor" id="a1e43c788c40e9783311c970bcea7239b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#a1e43c788c40e9783311c970bcea7239b" title="Thread::Finish Called by ThreadRoot when a thread is done executing the forked procedure. ">Thread::Finish</a> Called by ThreadRoot when a thread is done executing the forked procedure. </p>
<p>NOTE: we don't immediately de-allocate the thread data structure or the execution stack, because we're still running in the thread and we're still on the stack! Instead, we set "threadToBeDestroyed", so that <a class="el" href="class_scheduler.html#a87205b0773d3dd84752ec779c890f5e1" title="Scheduler::Run Dispatch the CPU to nextThread. Save the state of the old thread, and load the state o...">Scheduler::Run()</a> will call the destructor, once we're running in the context of a different thread.</p>
<p>NOTE: we disable interrupts, so that we don't get a time slice between setting threadToBeDestroyed, and going to sleep. </p>

</div>
</div>
<a class="anchor" id="a7631955bc5e11232bb682baa467baf5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Fork </td>
          <td>(</td>
          <td class="paramtype">VoidFunctionPtr&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#a7631955bc5e11232bb682baa467baf5f" title="Thread::Fork Invoke (*func)(arg), allowing caller and callee to execute concurrently. ">Thread::Fork</a> Invoke (*func)(arg), allowing caller and callee to execute concurrently. </p>
<p>NOTE: although our definition allows only a single integer argument to be passed to the procedure, it is possible to pass multiple arguments by making them fields of a structure, and passing a pointer to the structure as "arg".</p>
<p>Implemented as the following steps:</p><ol type="1">
<li>Allocate a stack</li>
<li>Initialize the stack so that a call to SWITCH will cause it to run the procedure</li>
<li>Put the thread on the ready queue</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>is the procedure to run concurrently. </td></tr>
    <tr><td class="paramname">arg</td><td>is a single argument to be passed to the procedure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39061ce2692542188f82f909d005b1c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::setStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ae2739961013a00cede621d4d72f2173c">ThreadStatus</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#a39061ce2692542188f82f909d005b1c3" title="Thread::setStatus Set the status as in parameter with debug info. ">Thread::setStatus</a> Set the status as in parameter with debug info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ThreadStatus</td><td>st </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a187a4c1e62087511b69068220840244a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#a187a4c1e62087511b69068220840244a" title="Thread::Sleep Relinquish the CPU, because the current thread is blocked waiting on a synchronization ...">Thread::Sleep</a> Relinquish the CPU, because the current thread is blocked waiting on a synchronization variable (<a class="el" href="class_semaphore.html" title="The following class defines a &quot;semaphore&quot; whose value is a non-negative integer. The semaphore has on...">Semaphore</a>, <a class="el" href="class_lock.html">Lock</a>, or <a class="el" href="class_condition.html">Condition</a>). Eventually, some thread will wake this thread up, and put it back on the ready queue, so that it can be re-scheduled. </p>
<p>NOTE: if there are no threads on the ready queue, that means we have no thread to run. "Interrupt::Idle" is called to signify that we should idle the CPU until the next I/O interrupt occurs (the only thing that could cause a thread to become ready to run).</p>
<p>NOTE: we assume interrupts are already disabled, because it is called from the synchronization routines which must disable interrupts for atomicity. We need interrupts off so that there can't be a time slice between pulling the first thread off the ready list, and switching to it. </p>

</div>
</div>
<a class="anchor" id="adbc2bfb172d2eff4b46882aade9eeb8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_thread.html#adbc2bfb172d2eff4b46882aade9eeb8a" title="Thread::Yield Relinquish the CPU if any other thread is ready to run. If so, put the thread on the en...">Thread::Yield</a> Relinquish the CPU if any other thread is ready to run. If so, put the thread on the end of the ready list, so that it will eventually be re-scheduled. </p>
<p>NOTE: returns immediately if no other thread on the ready queue. Otherwise returns when the thread eventually works its way to the front of the ready list and gets re-scheduled.</p>
<p>NOTE: we disable interrupts, so that looking at the thread on the front of the ready list, and switching to it, can be done atomically. On return, we re-set the interrupt level to its original state, in case we are called with interrupts disabled.</p>
<p>Similar to <a class="el" href="class_thread.html#a187a4c1e62087511b69068220840244a" title="Thread::Sleep Relinquish the CPU, because the current thread is blocked waiting on a synchronization ...">Thread::Sleep()</a>, but a little different. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>code/threads/<a class="el" href="thread_8h_source.html">thread.h</a></li>
<li>code/threads/<a class="el" href="thread_8cc.html">thread.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
