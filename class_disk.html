<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tac0S: Disk Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tac0S
   </div>
   <div id="projectbrief">Template Affectional Command Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_disk-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Disk Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The following class defines a physical disk I/O device. The disk has a single surface, split up into "tracks", and each track split up into "sectors" (the same number of sectors on each track, and each sector has the same number of bytes of storage).  
 <a href="class_disk.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="disk_8h_source.html">disk.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e2ac7e4ca32bbec9b1acb015a4a71fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disk.html#a3e2ac7e4ca32bbec9b1acb015a4a71fa">Disk</a> (const char *name, VoidFunctionPtr callWhenDone, int callArg)</td></tr>
<tr class="memdesc:a3e2ac7e4ca32bbec9b1acb015a4a71fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disk.html#a3e2ac7e4ca32bbec9b1acb015a4a71fa" title="Disk::Disk() Initialize a simulated disk. Open the UNIX file (creating it if it doesn&#39;t exist)...">Disk::Disk()</a> Initialize a simulated disk. Open the UNIX file (creating it if it doesn't exist), and check the magic number to make sure it's ok to treat it as Nachos disk storage.  <a href="#a3e2ac7e4ca32bbec9b1acb015a4a71fa">More...</a><br /></td></tr>
<tr class="separator:a3e2ac7e4ca32bbec9b1acb015a4a71fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77518c808f3f5d9e902a55942542c337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77518c808f3f5d9e902a55942542c337"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disk.html#a77518c808f3f5d9e902a55942542c337">~Disk</a> ()</td></tr>
<tr class="memdesc:a77518c808f3f5d9e902a55942542c337"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disk.html#a77518c808f3f5d9e902a55942542c337" title="Disk::~Disk() Clean up disk simulation, by closing the UNIX file representing the disk...">Disk::~Disk()</a> Clean up disk simulation, by closing the UNIX file representing the disk. <br /></td></tr>
<tr class="separator:a77518c808f3f5d9e902a55942542c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b51a82d4f2fd009335d0c591ae11042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disk.html#a8b51a82d4f2fd009335d0c591ae11042">ReadRequest</a> (int sectorNumber, char *<a class="el" href="structdata.html">data</a>)</td></tr>
<tr class="memdesc:a8b51a82d4f2fd009335d0c591ae11042"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disk.html#a8b51a82d4f2fd009335d0c591ae11042" title="Disk::ReadRequest/WriteRequest Simulate a request to read/write a single disk sector Do the read/writ...">Disk::ReadRequest</a>/WriteRequest Simulate a request to read/write a single disk sector Do the read/write immediately to the UNIX file Set up an interrupt handler to be called later, that will notify the caller when the simulator says the operation has completed.  <a href="#a8b51a82d4f2fd009335d0c591ae11042">More...</a><br /></td></tr>
<tr class="separator:a8b51a82d4f2fd009335d0c591ae11042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33797c6480a8c919fc7d340c316abe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec33797c6480a8c919fc7d340c316abe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteRequest</b> (int sectorNumber, char *<a class="el" href="structdata.html">data</a>)</td></tr>
<tr class="separator:aec33797c6480a8c919fc7d340c316abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d4a38e61501c221163ef845b9d6969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d4a38e61501c221163ef845b9d6969"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disk.html#a32d4a38e61501c221163ef845b9d6969">HandleInterrupt</a> ()</td></tr>
<tr class="memdesc:a32d4a38e61501c221163ef845b9d6969"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disk.html#a32d4a38e61501c221163ef845b9d6969" title="Disk::HandleInterrupt() Called when it is time to invoke the disk interrupt handler, to tell the Nachos kernel that the disk request is done. ">Disk::HandleInterrupt()</a> Called when it is time to invoke the disk interrupt handler, to tell the Nachos kernel that the disk request is done. <br /></td></tr>
<tr class="separator:a32d4a38e61501c221163ef845b9d6969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2337b1c68eb5f6a15502d8327d15248b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_disk.html#a2337b1c68eb5f6a15502d8327d15248b">ComputeLatency</a> (int newSector, bool writing)</td></tr>
<tr class="memdesc:a2337b1c68eb5f6a15502d8327d15248b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_disk.html#a2337b1c68eb5f6a15502d8327d15248b" title="Disk::ComputeLatency() Return how long will it take to read/write a disk sector, from the current pos...">Disk::ComputeLatency()</a> Return how long will it take to read/write a disk sector, from the current position of the disk head.  <a href="#a2337b1c68eb5f6a15502d8327d15248b">More...</a><br /></td></tr>
<tr class="separator:a2337b1c68eb5f6a15502d8327d15248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The following class defines a physical disk I/O device. The disk has a single surface, split up into "tracks", and each track split up into "sectors" (the same number of sectors on each track, and each sector has the same number of bytes of storage). </p>
<p>Addressing is by sector number &ndash; each sector on the disk is given a unique number: track * SectorsPerTrack + offset within a track.</p>
<p>As with other I/O devices, the raw physical disk is an asynchronous device &ndash; requests to read or write portions of the disk return immediately, and an interrupt is invoked later to signal that the operation completed.</p>
<p>The physical disk is in fact simulated via operations on a UNIX file.</p>
<p>To make life a little more realistic, the simulated time for each operation reflects a "track buffer" &ndash; RAM to store the contents of the current track as the disk head passes by. The idea is that the disk always transfers to the track buffer, in case that data is requested later on. This has the benefit of eliminating the need for "skip-sector" scheduling &ndash; a read request which comes in shortly after the head has passed the beginning of the sector can be satisfied more quickly, because its contents are in the track buffer. Most disks these days now come with a track buffer.</p>
<p>The track buffer simulation can be disabled by compiling with -DNOTRACKBUF </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3e2ac7e4ca32bbec9b1acb015a4a71fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Disk::Disk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VoidFunctionPtr&#160;</td>
          <td class="paramname"><em>callWhenDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_disk.html#a3e2ac7e4ca32bbec9b1acb015a4a71fa" title="Disk::Disk() Initialize a simulated disk. Open the UNIX file (creating it if it doesn&#39;t exist)...">Disk::Disk()</a> Initialize a simulated disk. Open the UNIX file (creating it if it doesn't exist), and check the magic number to make sure it's ok to treat it as Nachos disk storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>&ndash; text name of the file simulating the Nachos disk </td></tr>
    <tr><td class="paramname">callWhenDone</td><td>&ndash; interrupt handler to be called when disk read/write request completes </td></tr>
    <tr><td class="paramname">callArg</td><td>&ndash; argument to pass the interrupt handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2337b1c68eb5f6a15502d8327d15248b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Disk::ComputeLatency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_disk.html#a2337b1c68eb5f6a15502d8327d15248b" title="Disk::ComputeLatency() Return how long will it take to read/write a disk sector, from the current pos...">Disk::ComputeLatency()</a> Return how long will it take to read/write a disk sector, from the current position of the disk head. </p>
<p>Latency = seek time + rotational latency + transfer time <a class="el" href="class_disk.html" title="The following class defines a physical disk I/O device. The disk has a single surface, split up into &quot;tracks&quot;, and each track split up into &quot;sectors&quot; (the same number of sectors on each track, and each sector has the same number of bytes of storage). ">Disk</a> seeks at one track per SeekTime ticks (cf. <a class="el" href="stats_8h.html" title="Implementation of system-dependent interface. ">stats.h</a>) and rotates at one sector per RotationTime ticks</p>
<p>To find the rotational latency, we first must figure out where the disk head will be after the seek (if any). We then figure out how long it will take to rotate completely past newSector after that point.</p>
<p>The disk also has a "track buffer"; the disk continuously reads the contents of the current disk track into the buffer. This allows read requests to the current track to be satisfied more quickly. The contents of the track buffer are discarded after every seek to a new track. </p>

</div>
</div>
<a class="anchor" id="a8b51a82d4f2fd009335d0c591ae11042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Disk::ReadRequest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sectorNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_disk.html#a8b51a82d4f2fd009335d0c591ae11042" title="Disk::ReadRequest/WriteRequest Simulate a request to read/write a single disk sector Do the read/writ...">Disk::ReadRequest</a>/WriteRequest Simulate a request to read/write a single disk sector Do the read/write immediately to the UNIX file Set up an interrupt handler to be called later, that will notify the caller when the simulator says the operation has completed. </p>
<p>Note that a disk only allows an entire sector to be read/written, not part of a sector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorNumber</td><td>&ndash; the disk sector to read/write </td></tr>
    <tr><td class="paramname">data</td><td>&ndash; the bytes to be written, the buffer to hold the incoming bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>code/machine/<a class="el" href="disk_8h_source.html">disk.h</a></li>
<li>code/machine/<a class="el" href="disk_8cc.html">disk.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
